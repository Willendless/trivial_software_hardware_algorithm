# 一些软硬件算法的模拟与实现

- [一些软硬件算法的模拟与实现](#一些软硬件算法的模拟与实现)
  - [TAPSA 单处理器优先级调度](#tapsa-单处理器优先级调度)
  - [MUPSA 多处理器优先级调度](#mupsa-多处理器优先级调度)
  - [MMM 多模块划分算法](#mmm-多模块划分算法)
    - [应用: 多处理器任务分配](#应用-多处理器任务分配)
  - [KL算法 2式划分](#kl算法-2式划分)
  - [微系统划分方法](#微系统划分方法)
    - [基于模块的多任务划分](#基于模块的多任务划分)
    - [异构多核多任务划分](#异构多核多任务划分)
      - [HSPAhg: 基于硬件实现增益的软硬件划分](#hspahg-基于硬件实现增益的软硬件划分)
      - [HSPAhga: 基于硬件实现增益 + 硬件面积的软硬件划分](#hspahga-基于硬件实现增益--硬件面积的软硬件划分)
      - [HSPAahg: 基于硬件面积 + 硬件实现增益的软硬件划分](#hspaahg-基于硬件面积--硬件实现增益的软硬件划分)

## TAPSA 单处理器优先级调度

单个处理器基于表的优先级计算与排序。

`任务i的优先级 = 任务i的执行时间 + 任务i的出度 + 任务i后继节点的最大优先级值`

输入文件格式

```c
5 // 5个任务
1 0 // 任务1执行时间为1，释放时间为0
1 3 // 任务2
2 0 // 任务3
1 0 // 任务4
1 0 // 任务5
1 4 // 依赖关系：1->4
1 5 // 依赖关系：1->5
2 4 // 依赖关系: 2->4
2 5 // 依赖关系: 2->5
3 5 // 依赖关系: 3->5
```

## MUPSA 多处理器优先级调度

在TAPSA计算得到的优先级基础上，对多个处理器进行优先级调度的模拟。本实现支持非抢占式和抢占式两种配置。

输入文件格式

```c
0   // 0表示非抢占式，1表示抢占式
5 2 // 5个任务，2个cpu
1 0 // 任务1执行时间为1，释放时间为0
1 3 // 任务2
2 0 // 任务3
1 0 // 任务4
1 0 // 任务5
1 4 // 依赖关系：1->4
1 5 // 依赖关系：1->5
2 4 // 依赖关系: 2->4
2 5 // 依赖关系: 2->5
3 5 // 依赖关系: 3->5
```

## MMM 多模块划分算法

> 这里的模块也即簇。

执行命令

```shell
$ g++ mmm.c
$ ./a.out [input file] [0/1/2]
```

最后一个参数用于选择两模块是否能合并的算法。

+ 0: 使用单链接
+ 1: 使用全链接
+ 2: 使用均链接

输入文件格式

```c
10 3 4 1// 总任务数，最终划分模块数，单个模块内任务数上限, 单个模块内任务数下限
1 2 1 // 任务1，2间通信代价为1
1 7 4
1 9 2
2 3 3
3 8 2
3 10 1
4 6 2
4 8 5
4 9 6
5 8 3
5 9 7
5 10 8
6 7 1
```

输出为三元组`<c, k, K>`，分别表示

+ 通信代价阈值
+ 划分后模块的数量
+ 模块集合

### 应用: 多处理器任务分配

+ 多处理器任务分配：将n个任务分配到m个处理器上使得通信代价最小
  + 等价于将n个任务划分为m个模块

## KL算法 2式划分

希望找到一个2式划分使得两个集合间的通信代价最小。

执行命令

```shell
g++ kl.cpp
./a.out [input file]
```

输入文件格式

```c
8 // 总节点数
0   1  .5   0  .5   1   0  .5 // 边权矩阵
1   0  .5   0   0   0   0   0
.5 .5   0  .5   1  .5   0   0
0   0  .5   0   0   1   0  .5
.5  0   1   0   0  .5   1   0
1   0  .5   1  .5   0  .5  .5
0   0   0   0   1  .5   0  .5
.5  0   0  .5   0  .5  .5   0
```

输出为100次计算的最终划分结果和总的通信代价。

## 微系统划分方法

### 基于模块的多任务划分

+ 首先，基于**通信代价**对多个任务进行多模块划分
  + MMM算法
  + KL算法
+ 接着，在每个模块内部依据**软硬时间、功耗、面积**等约束，通过线性规划进行软硬件划分
  + lingo
  + matlab

这里实现了输出lingo文件的脚本

输入文件格式

```c
3 4     // 总任务数 总属性数
T1      // 目标1
1 2 3   // 软件开销
2 3 4   // 硬件开销
T2      // 目标2
1 2 3   // 软件开销
2 3 4   // 硬件开销
R1      // 约束1
1 2 3   // 软件开销
2 3 4   // 硬件开销
R2      // 约束2
0 2 1   // 软件开销
2 1 3   // 硬件开销
```

每次迭代程序会要求输出当前模块的任务分别是什么。

### 异构多核多任务划分

+ 每个任务需要考虑
  + 时间：**软件执行时间**、**硬件执行时间**、**任务释放时间**
  + 其它: **硬件执行面积**
+ 相互依赖的任务要考虑**通信代价**
  + 通信代价作为算法运行时约束

#### HSPAhg: 基于硬件实现增益的软硬件划分

heuristic: 硬件实现增益越大，越应该优先执行。任务划分在线确定。

硬件实现增益：硬件实现时间 - 软件实现时间

用硬件实现增益表示时间属性，硬件执行面积仅作为动态约束条件，计算任务优先级表，并使用MUPSA算法获取任务分配方案。

实现: todo

#### HSPAhga: 基于硬件实现增益 + 硬件面积的软硬件划分

heuristic: 从硬件面积角度，尽可能多安排硬件执行任务。具体而言，面积较大的强制分配给软件执行。

1. 计算任务需要硬件面积的平均值，进而计算硬件执行平均任务数`k`（即硬件面积约束 / 任务需要硬件面积平均值）。对任务按硬件执行面积排序，前n-k个通过硬件执行列表维护，后k个通过软件执行列表维护。
2. 同HSPAhg以硬件实现增益为时间属性，计算任务优先级表。
3. 对可执行的最高优先级任务进行调度
   1. 属于硬件执行列表:  若硬件面积不满足约束，放入软件执行列表。否则在硬件空闲时分配给硬件执行。
   2. 属于软件执行列表: 当有软核空闲时，分配给空闲较长的软核。否则不分配直到条件满足。

实现: todo

#### HSPAahg: 基于硬件面积 + 硬件实现增益的软硬件划分

heuristic: 通过线性规划离线确定任务划分。

1. 使用线性规划离线确定硬件和软件实现的任务。
    + 目标是在硬件面积的约束下，使得硬件增益最大。
2. 计算任务优先级: 硬件任务考虑硬件时间，软件任务考虑软件时间，生成任务优先级表
    + 硬件执行任务优先级：`硬件执行时间 + 任务出度 + max{后继任务的通信时间 + 优先级}`
    + 软件执行任务优先级：`软件执行时间 + 任务出度 + max{后继任务的通信时间 + 优先级}`
3. 对可执行的最高优先级软件/硬件任务进行调度
   1. 硬件任务: 若有硬核空闲则分配，否则直到下一个硬核空闲。
   2. 软件任务: 若有软核空闲则分配，否则直到下一个软核空闲。
