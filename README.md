# 1. 一些软硬件算法的模拟与实现

- [1. 一些软硬件算法的模拟与实现](#1-一些软硬件算法的模拟与实现)
  - [1.1. TAPSA 单处理器优先级调度](#11-tapsa-单处理器优先级调度)
  - [1.2. MUPSA 多处理器优先级调度](#12-mupsa-多处理器优先级调度)
  - [1.3. MMM 多模块划分算法](#13-mmm-多模块划分算法)
    - [1.3.1. 应用: 多处理器任务分配](#131-应用-多处理器任务分配)
  - [1.4. KL算法 2式划分](#14-kl算法-2式划分)
  - [1.5. 微系统划分方法](#15-微系统划分方法)
    - [1.5.1. 基于模块的多任务划分](#151-基于模块的多任务划分)
    - [1.5.2. 异构多核多任务划分](#152-异构多核多任务划分)
      - [1.5.2.1. HSPAhg: 基于硬件实现增益的软硬件划分](#1521-hspahg-基于硬件实现增益的软硬件划分)
      - [1.5.2.2. HSPAhga: 基于硬件实现增益 + 硬件面积的软硬件划分](#1522-hspahga-基于硬件实现增益--硬件面积的软硬件划分)
      - [1.5.2.3. HSPAahg: 基于硬件面积 + 硬件实现增益的软硬件划分](#1523-hspaahg-基于硬件面积--硬件实现增益的软硬件划分)

## 1.1. TAPSA 单处理器优先级调度

单个处理器基于表的优先级计算与排序。

`任务i的优先级 = 任务i的执行时间 + 任务i的出度 + 任务i后继节点的最大优先级值`

输入文件格式

```c
5 // 5个任务
1 0 // 任务1执行时间为1，释放时间为0
1 3 // 任务2
2 0 // 任务3
1 0 // 任务4
1 0 // 任务5
1 4 // 依赖关系：1->4
1 5 // 依赖关系：1->5
2 4 // 依赖关系: 2->4
2 5 // 依赖关系: 2->5
3 5 // 依赖关系: 3->5
```

## 1.2. MUPSA 多处理器优先级调度

在TAPSA计算得到的优先级基础上，对多个处理器进行优先级调度的模拟。本实现支持非抢占式和抢占式两种配置。

输入文件格式

```c
0   // 0表示非抢占式，1表示抢占式
5 2 // 5个任务，2个cpu
1 0 // 任务1执行时间为1，释放时间为0
1 3 // 任务2
2 0 // 任务3
1 0 // 任务4
1 0 // 任务5
1 4 // 依赖关系：1->4
1 5 // 依赖关系：1->5
2 4 // 依赖关系: 2->4
2 5 // 依赖关系: 2->5
3 5 // 依赖关系: 3->5
```

## 1.3. MMM 多模块划分算法

> 这里的模块也即簇。

执行命令

```shell
$ g++ mmm.c
$ ./a.out [input file] [0/1/2]
```

最后一个参数用于选择两模块是否能合并的算法。

+ 0: 使用单链接
+ 1: 使用全链接
+ 2: 使用均链接

输入文件格式

```c
10 3 4 1// 总任务数，最终划分模块数，单个模块内任务数上限, 单个模块内任务数下限
1 2 1 // 任务1，2间通信代价为1
1 7 4
1 9 2
2 3 3
3 8 2
3 10 1
4 6 2
4 8 5
4 9 6
5 8 3
5 9 7
5 10 8
6 7 1
```

输出为三元组`<c, k, K>`，分别表示

+ 通信代价阈值
+ 划分后模块的数量
+ 模块集合

### 1.3.1. 应用: 多处理器任务分配

+ 多处理器任务分配：将n个任务分配到m个处理器上使得通信代价最小
  + 等价于将n个任务划分为m个模块

## 1.4. KL算法 2式划分

希望找到一个2式划分使得两个集合间的通信代价最小。

执行命令

```shell
g++ kl.cpp
./a.out [input file]
```

输入文件格式

```c
8 // 总节点数
0   1  .5   0  .5   1   0  .5 // 边权矩阵
1   0  .5   0   0   0   0   0
.5 .5   0  .5   1  .5   0   0
0   0  .5   0   0   1   0  .5
.5  0   1   0   0  .5   1   0
1   0  .5   1  .5   0  .5  .5
0   0   0   0   1  .5   0  .5
.5  0   0  .5   0  .5  .5   0
```

输出为100次计算的最终划分结果和总的通信代价。

## 1.5. 微系统划分方法

### 1.5.1. 基于模块的多任务划分

+ 首先，基于**通信代价**对多个任务进行多模块划分
  + MMM算法
  + KL算法
+ 接着，在每个模块内部依据**软硬时间、功耗、面积**等约束，通过线性规划进行软硬件划分
  + lingo
  + matlab

这里实现了输出lingo文件的脚本

输入文件格式

```c
3 4     // 总任务数 总属性数
T1      // 目标1
1 2 3   // 软件开销
2 3 4   // 硬件开销
T2      // 目标2
1 2 3   // 软件开销
2 3 4   // 硬件开销
R1      // 约束1
1 2 3   // 软件开销
2 3 4   // 硬件开销
R2      // 约束2
0 2 1   // 软件开销
2 1 3   // 硬件开销
```

每次迭代程序会要求输出当前模块的任务分别是什么。

### 1.5.2. 异构多核多任务划分

+ 每个任务需要考虑
  + 时间：**软件执行时间**、**硬件执行时间**、**任务释放时间**
  + 其它: **硬件执行面积**
+ 相互依赖的任务要考虑**通信代价**
  + 通信代价作为算法运行时约束

#### 1.5.2.1. HSPAhg: 基于硬件实现增益的软硬件划分

heuristic: 硬件实现增益越大，越应该优先执行。任务划分在线确定。

硬件实现增益：硬件实现时间 - 软件实现时间

用硬件实现增益表示时间属性，硬件执行面积仅作为动态约束条件，计算任务优先级表，并使用MUPSA算法获取任务分配方案。

实现: todo

#### 1.5.2.2. HSPAhga: 基于硬件实现增益 + 硬件面积的软硬件划分

heuristic: 从硬件面积角度，尽可能多安排硬件执行任务。具体而言，面积较大的强制分配给软件执行。

1. 计算任务需要硬件面积的平均值，进而计算硬件执行平均任务数`k`（即硬件面积约束 / 任务需要硬件面积平均值）。对任务按硬件执行面积排序，前n-k个通过硬件执行列表维护，后k个通过软件执行列表维护。
2. 同HSPAhg以硬件实现增益为时间属性，计算任务优先级表。
3. 对可执行的最高优先级任务进行调度
   1. 属于硬件执行列表:  若硬件面积不满足约束，放入软件执行列表。否则在硬件空闲时分配给硬件执行。
   2. 属于软件执行列表: 当有软核空闲时，分配给空闲较长的软核。否则不分配直到条件满足。

实现: todo

#### 1.5.2.3. HSPAahg: 基于硬件面积 + 硬件实现增益的软硬件划分

heuristic: 通过线性规划离线确定任务划分。

1. 使用线性规划离线确定硬件和软件实现的任务。
    + 目标是在硬件面积的约束下，使得硬件增益最大。
2. 计算任务优先级: 硬件任务考虑硬件时间，软件任务考虑软件时间，生成任务优先级表
    + 硬件执行任务优先级：`硬件执行时间 + 任务出度 + max{后继任务的通信时间 + 优先级}`
    + 软件执行任务优先级：`软件执行时间 + 任务出度 + max{后继任务的通信时间 + 优先级}`
3. 对可执行的最高优先级软件/硬件任务进行调度
   1. 硬件任务: 若有硬核空闲则分配，否则直到下一个硬核空闲。
   2. 软件任务: 若有软核空闲则分配，否则直到下一个软核空闲。

```c
11 2   // 11个总任务, 执行者数：2表示有两个执行者
// 第一个执行者
6 2 // 6个任务，2个核
2 3 0 // 任务2执行时间为3，释放时间为0
6 10 0 // 任务6
8 2 0 // 任务8
9 7 0 // 任务9
10 2 0 // 任务10
11 9 0 // 任务11
// 第二个执行者
5 2 // 5个任务, 2个软/硬核
1 4 0 // 任务1执行时间为4，释放时间为0
3 4 0
4 5 0
5 3 0
7 3 0
// 依赖关系
1 4 1 // 依赖关系：1->4 权重: 1
2 4 2 // 依赖关系: 1->4 权重: 2
2 5 2 // 依赖关系: 2->5 权重: 2
3 5 1 // 依赖关系: 3->5 权重: 1 (下同)
4 6 4
4 7 1
5 8 1
5 9 2
6 10 3
7 10 1
8 11 1
9 11 2
```

输出部分除了优先级表、trace、统计信息外，还会生成一个`mermaid_out.mmd`文件，该文件是一个mermaid的脚本，可以用于生成gantt图。一个在线根据mermaid脚本生成图片的网站是[mermaid-online-editor](https://mermaid-js.github.io/mermaid-live-editor)。
